//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<retAttr,A> {

	Integer debug = 0;
	boolean idCheck = false;
	String curClass = null;
	Integer code = 0;
	Integer lable = 0;

    String getNewCode() {
        code++;
        return "TEMP "+Integer.toString(code.intValue());
    }

	String getNewLable() {
        lable++;
        return "L"+Integer.toString(lable.intValue());
    }

	void print(String s)
	{
		System.out.println(s);
	}

	class varElem extends varAttr{ 
		String code;
		varElem(varAttr vattr)
		{
			super(vattr.name, vattr.type, vattr.cname, vattr.mname, vattr.offset, vattr.loc);
			code = getNewCode();
		}

		public String load(String code)
		{
			if(loc.equals(LOC.CLASS)) 
			{
				print("HLOAD "+code+" TEMP 0 "+offset);
				return code;
			}
			return this.code;
		}

		public void store(String code)
		{
			if(loc.equals(LOC.CLASS)) print("HSTORE TEMP 0 "+offset+" "+code);
			else print("MOVE "+this.code+" "+code);
		}
	}

	public Map<String, classAttr> classTable = new HashMap<String, classAttr>();
	private Map<String, Stack<varElem>> varTypeMap = new HashMap<String, Stack<varElem>>();

	methAttr getMeth(String cname, String mname)
	{
		classAttr c = classTable.get(cname);
		for (methAttr m : c.methList) {
			if (m.name.equals(mname)) {
				return m;
			}
		}
		return null;
	}

	void addToScope(ArrayList<varAttr> lst)
	{
		for(int i=0;i<lst.size();i++)
		{
			if(!varTypeMap.containsKey(lst.get(i).name))
			{
				varTypeMap.put(lst.get(i).name,new Stack<varElem>());
			}
			varTypeMap.get(lst.get(i).name).push(new varElem(lst.get(i)));
		}
	}

	void removeFromScope(ArrayList<varAttr> lst)
	{
		for(int i=0;i<lst.size();i++)
		{
			varTypeMap.get(lst.get(i).name).pop();
		}
	}

	void initMem(String start, int size, boolean init)
	{
		String temp = getNewCode();
		print("MOVE "+temp+" "+(4*size));
		print("MOVE "+start+" HALLOCATE "+temp);
		if(init)
		{
			String zero = getNewCode();
			print("MOVE "+zero+" 0");
			for(int i=0;i<size;i++)
			{
				print("HSTORE "+start+" "+4*i+" "+zero);
			}
			code--;
		}
		code--;
	}

	retAttr createNewClass (String cname)
	{
		classAttr cattr = classTable.get(cname);

		retAttr ctable = new retAttr(getNewCode(),cname);
		String mtable = getNewCode();
		String name = getNewCode();
		initMem(ctable.code,cattr.varList.size()+1,true);
		initMem(mtable, cattr.methList.size(),false);

		for(int i=cattr.methList.size()-1;i>=0;i--)
		{
			print("MOVE "+name+" "+cattr.methList.get(i).code);
			print("HSTORE "+mtable+" "+i*4+" "+name);
		}
		print("HSTORE "+ctable.code+" 0 "+mtable);

		code-=2;
		return ctable;
	} 

	// Auto class visitors--probably don't need to be overridden.

	public retAttr visit(NodeList n, A argu) {
		retAttr _ret=null;
		Integer _count=0;
		for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
			e.nextElement().accept(this,argu);
			_count++;
		}
		return _ret;
	}

	public retAttr visit(NodeListOptional n, A argu) {
		if ( n.present() ) {
			retAttr _ret=null;
			Integer _count=0;
			for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
				e.nextElement().accept(this,argu);
				_count++;
			}
			return _ret;
		}
		else
			return null;
	}

	public retAttr visit(NodeOptional n, A argu) {
		if ( n.present() )
			return n.node.accept(this,argu);
		else
			return null;
	}

	public retAttr visit(NodeSequence n, A argu) {
		retAttr _ret=null;
		Integer _count=0;
		for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
			e.nextElement().accept(this,argu);
			_count++;
		}
		return _ret;
	}

	public retAttr visit(NodeToken n, A argu) 
	{
		retAttr _ret = new retAttr(n.tokenImage, null);
		return _ret; 
	}

	//
	// User-generated visitor methods below
	//

	/** Goal!!!
	* f0 -> MainClass()
	* f1 -> ( TypeDeclaration() )*
	* f2 -> <EOF>
	*/
	public retAttr visit(Goal n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		return null;
	}

	/** MainClass!!!
	* f0 -> "class"
	* f1 -> Identifier()
	* f2 -> "{"
	* f3 -> "public"
	* f4 -> "static"
	* f5 -> "void"
	* f6 -> "main"
	* f7 -> "("
	* f8 -> "String"
	* f9 -> "["
	* f10 -> "]"
	* f11 -> Identifier()
	* f12 -> ")"
	* f13 -> "{"
	* f14 -> PrintStatement()
	* f15 -> "}"
	* f16 -> "}"
	*/
	public retAttr visit(MainClass n, A argu) 
	{
		code = 0;
		print("MAIN");
		n.f14.accept(this, null);
		print("END");
		return null;
	}

	/**   TypeDeclaration!!!
		* f0 -> ClassDeclaration()
		*       | ClassExtendsDeclaration()
		*/
	public retAttr visit(TypeDeclaration n, A argu) 
	{
		return n.f0.accept(this, null);
	}

	/**   ClassDeclaration!!!
	* f0 -> "class"
	* f1 -> Identifier()
	* f2 -> "{"
	* f3 -> ( VarDeclaration() )*
	* f4 -> ( MethodDeclaration() )*
	* f5 -> "}"
	*/
	public retAttr visit(ClassDeclaration n, A argu) 
	{
		code = 0;
		curClass = n.f1.f0.tokenImage;
		classAttr cattr = classTable.get(curClass);
		addToScope(cattr.varList);
		n.f4.accept(this, null);
		removeFromScope(cattr.varList);
		return null;
	}

	/**   ClassExtendsDeclaration!!!
	* f0 -> "class"
	* f1 -> Identifier()
	* f2 -> "extends"
	* f3 -> Identifier()
	* f4 -> "{"
	* f5 -> ( VarDeclaration() )*
	* f6 -> ( MethodDeclaration() )*
	* f7 -> "}"
	*/
	public retAttr visit(ClassExtendsDeclaration n, A argu) 
	{
		code = 0;
		curClass = n.f1.f0.tokenImage;
		classAttr cattr = classTable.get(curClass);
		addToScope(cattr.varList);
		n.f6.accept(this, null);
		removeFromScope(cattr.varList);
		return null;
	}

	/**   VarDeclaration!!!
	* f0 -> Type()
	* f1 -> Identifier()
	* f2 -> ";"
	*/
	public retAttr visit(VarDeclaration n, A argu) 
	{
		return null;
	}

	/**   MethodDeclaration!!!
	* f0 -> "public"
	* f1 -> Type()
	* f2 -> Identifier()
	* f3 -> "("
	* f4 -> ( FormalParameterList() )?
	* f5 -> ")"
	* f6 -> "{"
	* f7 -> ( VarDeclaration() )*
	* f8 -> ( Statement() )*
	* f9 -> "return"
	* f10 -> Expression()
	* f11 -> ";"
	* f12 -> "}"
	*/
	public retAttr visit(MethodDeclaration n, A argu) 
	{
		code=0;
		lable = 0;
		methAttr mattr = null;
		classAttr c = classTable.get(curClass);
		for (methAttr m : c.methList) {
			if (m.name.equals(n.f2.f0.tokenImage) && m.cname.equals(curClass)) {
				mattr = m;
				break;
			}
		}
		
		addToScope(mattr.argList);
		addToScope(mattr.varList);
		print(mattr.code+" ["+(mattr.argList.size()+1)+"]");
		print("BEGIN");
		n.f8.accept(this, null);
		print("RETURN "+n.f10.accept(this, null).code);
		print("END");
		removeFromScope(mattr.varList);
		removeFromScope(mattr.argList);
		return null;
	}

	/**   FormalParameterList!!!
	* f0 -> FormalParameter()
	* f1 -> ( FormalParameterRest() )*
	*/
	public retAttr visit(FormalParameterList n, A argu) 
	{
		return null;
	}

	/**   FormalParameter!!!
	* f0 -> Type()
	* f1 -> Identifier()
	*/
	public retAttr visit(FormalParameter n, A argu) 
	{
		return null;
	}

	/**   FormalParameterRest!!!
	* f0 -> ","
	* f1 -> FormalParameter()
	*/
	public retAttr visit(FormalParameterRest n, A argu) 
	{
		return null;
	}

	/**   Type!!!
	* f0 -> ArrayType()
	*       | BooleanType()
	*       | IntegerType()
	*       | Identifier()
	*/
	public retAttr visit(Type n, A argu) 
	{
		return null;
	}

	/**   ArrayType!!!
	* f0 -> "int"
	* f1 -> "["
	* f2 -> "]"
	*/
	public retAttr visit(ArrayType n, A argu) 
	{
		return null;
	}

	/**   BooleanType!!!
	* f0 -> "boolean"
	*/
	public retAttr visit(BooleanType n, A argu) 
	{
		return null;
	}

	/**   IntegerType!!!
	* f0 -> "int"
	*/
	public retAttr visit(IntegerType n, A argu) 
	{
		return null;
	}

	/**   Statement!!!
	* f0 -> Block()
	*       | AssignmentStatement()
	*       | ArrayAssignmentStatement()
	*       | IfStatement()
	*       | WhileStatement()
	*       | PrintStatement()
	*/
	public retAttr visit(Statement n, A argu) 
	{
		return n.f0.accept(this, null);
	}

	/**   Block!!!
	* f0 -> "{"
	* f1 -> ( Statement() )*
	* f2 -> "}"
	*/
	public retAttr visit(Block n, A argu) 
	{
		return n.f1.accept(this, null);
	}

	/**   AssignmentStatement!!!
	* f0 -> Identifier()
	* f1 -> "="
	* f2 -> Expression()
	* f3 -> ";"
	*/
	public retAttr visit(AssignmentStatement n, A argu)
	{
		varTypeMap.get(n.f0.f0.tokenImage).peek().store(n.f2.accept(this, null).code);
		return null;
	}

	/**   ArrayAssignmentStatement!!!
	* f0 -> Identifier() - int[]
	* f1 -> "["
	* f2 -> Expression() - int
	* f3 -> "]"
	* f4 -> "="
	* f5 -> Expression() - int
	* f6 -> ";"
	*/
	public retAttr visit(ArrayAssignmentStatement n, A argu) 
	{
		String arr = getNewCode();
		arr = varTypeMap.get(n.f0.f0.tokenImage).peek().load(arr);
		String tmp = getNewCode();
		print("MOVE "+tmp+" TIMES "+n.f2.accept(this, null).code+" 4");
		print("MOVE "+tmp+" PLUS "+tmp+" 4");
		print("MOVE "+tmp+" PLUS "+tmp+" "+arr);
		print("HSTORE "+tmp+" 0 "+n.f5.accept(this,null).code);
		code-=2;
		return null;
	}

	/**   IfStatement!!!
	* f0 -> IfthenElseStatement()
	*       | IfthenStatement()
	*/
	public retAttr visit(IfStatement n, A argu) 
	{
		return n.f0.accept(this, null);
	}

	/**   IfthenStatement!!!
	* f0 -> "if"
	* f1 -> "("
	* f2 -> Expression() - boolean
	* f3 -> ")"
	* f4 -> Statement()
	*/
	public retAttr visit(IfthenStatement n, A argu) 
	{
		String l1 = getNewLable();
		print("CJUMP "+n.f2.accept(this, null).code+" "+l1);
		n.f4.accept(this, null);
		print(l1);
		print("NOOP");
		return null;
	}

	/**   IfthenElseStatement!!!
	* f0 -> "if"
	* f1 -> "("
	* f2 -> Expression() - boolean
	* f3 -> ")"
	* f4 -> Statement()
	* f5 -> "else"
	* f6 -> Statement()
	*/
	public retAttr visit(IfthenElseStatement n, A argu) 
	{
		String l1 = getNewLable();
		String l2 = getNewLable();
		print("CJUMP "+n.f2.accept(this, null).code+" "+l1);
		n.f4.accept(this, null);
		print("JUMP "+l2);
		print(l1);
		n.f6.accept(this, null);
		print(l2);
		print("NOOP");
		return null;
	}

	/**   WhileStatement!!!
	* f0 -> "while"
	* f1 -> "("
	* f2 -> Expression() - boolean
	* f3 -> ")"
	* f4 -> Statement()
	*/
	public retAttr visit(WhileStatement n, A argu) 
	{
		String l1 = getNewLable();
		String l2 = getNewLable();
		print(l1);
		print("CJUMP "+n.f2.accept(this, null).code+" "+l2);
		n.f4.accept(this, null);
		print("JUMP "+l1);
		print(l2);
		print("NOOP");
		return null;
	}

	/**   PrintStatement!!!
	* f0 -> "print"
	* f1 -> "("
	* f2 -> Expression() - int
	* f3 -> ")"
	* f4 -> ";"
	*/
	public retAttr visit(PrintStatement n, A argu) 
	{
		print("PRINT "+n.f2.accept(this,null).code);
		return null;
	}

	/**   Expression!!!
	* f0 -> OrExpression()
	*       | AndExpression()
	*       | CompareExpression()
	*       | neqExpression()
	*       | PlusExpression()
	*       | MinusExpression()
	*       | TimesExpression()
	*       | DivExpression()
	*       | ArrayLookup()
	*       | ArrayLength()
	*       | MessageSend()
	*       | PrimaryExpression()
	*/
	public retAttr visit(Expression n, A argu) 
	{	
		return n.f0.accept(this, null);
	}

	/**   AndExpression!!!
	* f0 -> PrimaryExpression() - boolean
	* f1 -> "&&"
	* f2 -> PrimaryExpression() - boolean
	*/
	public retAttr visit(AndExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"boolean");
		String l1 = getNewLable();
		String l2 = getNewLable();
		
		String p1 = n.f0.accept(this,null).code;
		print("CJUMP "+p1+" "+l1);
		String p2 = n.f2.accept(this,null).code;
		print("MOVE "+ans.code+" "+p2);
		print("JUMP "+l2);
		print(l1);
		print("MOVE "+ans.code+" "+p1);
		print(l2);
		print("NOOP");
		return ans;
	}

	/**   OrExpression!!!
	* f0 -> PrimaryExpression() - boolean
	* f1 -> "||"
	* f2 -> PrimaryExpression() - boolean
	*/
	public retAttr visit(OrExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"boolean");
		String l1 = getNewLable();
		String l2 = getNewLable();

		String p1 = n.f0.accept(this,null).code;
		print("CJUMP "+p1+" "+l1);
		print("MOVE "+ans.code+" "+p1);
		print("JUMP "+l2);
		print(l1);
		String p2 = n.f2.accept(this,null).code;
		print("MOVE "+ans.code+" "+p2);
		print(l2);
		print("NOOP");
		return ans;
	}

	/**   CompareExpression!!!
	* f0 -> PrimaryExpression() - int
	* f1 -> "<="
	* f2 -> PrimaryExpression() - int
	*/
	public retAttr visit(CompareExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"boolean");
		print("MOVE "+ans.code+" LE "+n.f0.accept(this,null).code+" "+n.f2.accept(this,null).code);
		return ans;
	}

	/**   neqExpression!!!
	* f0 -> PrimaryExpression() - t
	* f1 -> "!="
	* f2 -> PrimaryExpression() - t
	*/
	public retAttr visit(neqExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"boolean");
		print("MOVE "+ans.code+" NE "+n.f0.accept(this,null).code+" "+n.f2.accept(this,null).code);
		return ans;
	}

	/**   PlusExpression!!!
	* f0 -> PrimaryExpression() - int
	* f1 -> "+"
	* f2 -> PrimaryExpression() - int
	*/
	public retAttr visit(PlusExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"int");
		print("MOVE "+ans.code+" PLUS "+n.f0.accept(this,null).code+" "+n.f2.accept(this,null).code);
		return ans;
	}

	/**   MinusExpression!!!
	* f0 -> PrimaryExpression() - int
	* f1 -> "-"
	* f2 -> PrimaryExpression() - int
	*/
	public retAttr visit(MinusExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"int");
		print("MOVE "+ans.code+" MINUS "+n.f0.accept(this,null).code+" "+n.f2.accept(this,null).code);
		return ans;
	}

	/**   TimesExpression!!!
	* f0 -> PrimaryExpression() - int
	* f1 -> "*"
	* f2 -> PrimaryExpression() - int
	*/
	public retAttr visit(TimesExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"int");
		print("MOVE "+ans.code+" TIMES "+n.f0.accept(this,null).code+" "+n.f2.accept(this,null).code);
		return ans;
	}

	/**   DivExpression!!!
	* f0 -> PrimaryExpression() - int
	* f1 -> "/"
	* f2 -> PrimaryExpression() - int
	*/
	public retAttr visit(DivExpression n, A argu) 
	{
		retAttr ans = new retAttr(getNewCode(),"int");
		print("MOVE "+ans.code+" DIV "+n.f0.accept(this,null).code+" "+n.f2.accept(this,null).code);
		return ans;
	}

	/**   ArrayLookup!!!
	* f0 -> PrimaryExpression() - int[]
	* f1 -> "["
	* f2 -> PrimaryExpression() - int
	* f3 -> "]"
	*/
	public retAttr visit(ArrayLookup n, A argu)
	{
		retAttr elem = new retAttr(getNewCode(),"int");
		String arr = n.f0.accept(this, null).code;
		String ind = getNewCode();
		String tmp = getNewCode();
		print("MOVE "+ind+" TIMES "+n.f2.accept(this, null).code+" 4");
		print("MOVE "+ind+" PLUS "+ind+" 4");
		print("MOVE "+tmp+" PLUS "+arr+" "+ind);
		print("HLOAD "+elem.code+" "+tmp+" 0");
		code-=2;
		return elem;
	}

	/**   ArrayLength!!!
	* f0 -> PrimaryExpression() - int[]
	* f1 -> "."
	* f2 -> "length"
	*/
	public retAttr visit(ArrayLength n, A argu) 
	{
		retAttr len = new retAttr(getNewCode(),"int");
		String arr = n.f0.accept(this, null).code;
		print("HLOAD "+len.code+" "+arr+" 0");
		print("MOVE "+len.code+" MINUS "+len.code+" 1");
		return len;
	}

	/**   MessageSend!!!
	* f0 -> PrimaryExpression()
	* f1 -> "."
	* f2 -> Identifier()
	* f3 -> "("
	* f4 -> ( ExpressionList() )?
	* f5 -> ")"
	*/
	public retAttr visit(MessageSend n, A argu) 
	{
		retAttr var = n.f0.accept(this, null);
		methAttr mattr = getMeth(var.type, n.f2.f0.tokenImage);
		retAttr ans = new retAttr(getNewCode(),mattr.retType);

		String tmp = getNewCode();
		print("HLOAD "+tmp+" "+var.code+" 0");
		print("HLOAD "+tmp+" "+tmp+" "+mattr.offset);

		ArrayList<String> args = new ArrayList<String>();
		n.f4.accept(this, (A)args);
		String call = "MOVE "+ans.code+" CALL "+tmp+" ( "+var.code;
		for(String arg : args)
			call += " "+arg;
		call += " )";
		print(call);
		code--;
		return ans;
	}

	/**   ExpressionList!!!
	* f0 -> Expression()
	* f1 -> ( ExpressionRest() )*
	*/
	public retAttr visit(ExpressionList n, A argu) 
	{
		ArrayList<String> args = (ArrayList<String>)argu;
		args.add(n.f0.accept(this, argu).code);
		n.f1.accept(this, argu);
		return null;
	}

	/**   ExpressionRest!!!
	* f0 -> ","
	* f1 -> Expression()
	*/
	public retAttr visit(ExpressionRest n, A argu) 
	{
		ArrayList<String> args = (ArrayList<String>)argu;
		args.add(n.f1.accept(this, argu).code);
		return null;
	}

	/**   PrimaryExpression!!! 
	* f0 -> IntegerLiteral()
	*       | TrueLiteral()
	*       | FalseLiteral()
	*       | Identifier()
	*       | ThisExpression()
	*       | ArrayAllocationExpression()
	*       | AllocationExpression()
	*       | NotExpression()
	*       | BracketExpression()
	*/
	public retAttr visit(PrimaryExpression n, A argu) 
	{
		idCheck = false;
		retAttr ret =  n.f0.accept(this, null);
		if(idCheck)
		{
			idCheck = false;
			String val = getNewCode();
			val = varTypeMap.get(ret.code).peek().load(val);
			return new retAttr(val, varTypeMap.get(ret.code).peek().type);
		}
		else return ret;
	}

	/**   IntegerLiteral!!!
	* f0 -> <INTEGER_LITERAL>
	*/
	public retAttr visit(IntegerLiteral n, A argu) 
	{
		retAttr val = new retAttr(getNewCode(),"int");
		print("MOVE "+val.code+" "+n.f0.tokenImage);
		return val;
	}

	/**   TrueLiteral!!!
	* f0 -> "true"
	*/
	public retAttr visit(TrueLiteral n, A argu) 
	{
		retAttr val = new retAttr(getNewCode(),"boolean");
		print("MOVE "+val.code+" 1");
		return val;
	}

	/**   FalseLiteral!!!
	* f0 -> "false"
	*/
	public retAttr visit(FalseLiteral n, A argu)
	{
		retAttr val = new retAttr(getNewCode(),"boolean");
		print("MOVE "+val.code+" 0");
		return val;
	}

	/**   Identifier!!!
	* f0 -> <IDENTIFIER>
	*/
	public retAttr visit(Identifier n, A argu) 
	{
		idCheck = true;
		if(debug>0) print("Identifier: "+n.f0.tokenImage);
		return new retAttr(n.f0.tokenImage,null);
	}

	/**   ThisExpression!!!
	* f0 -> "this"
	*/
	public retAttr visit(ThisExpression n, A argu) 
	{
		return new retAttr("TEMP 0",curClass);
	}

	/**   ArrayAllocationExpression!!!
	* f0 -> "new"
	* f1 -> "int"
	* f2 -> "["
	* f3 -> Expression() - int
	* f4 -> "]"
	*/
	public retAttr visit(ArrayAllocationExpression n, A argu) 
	{
		retAttr arr = new retAttr(getNewCode(), "int[]");
		String sz = n.f3.accept(this, null).code;
		String tmp = getNewCode();
		String tmp2 = getNewCode();
		print("MOVE "+tmp+" PLUS "+sz+" 1");
		print("MOVE "+tmp2+" TIMES "+tmp+" 4");
		print("MOVE "+arr.code+" HALLOCATE "+tmp2);
		print("HSTORE "+arr.code+" 0 "+tmp);

		//initializing array elements to 0
		String l1 = getNewLable();
		String l2 = getNewLable();
		String ind = getNewCode();
		String elem = getNewCode();
		String zero = getNewCode();
		print("MOVE "+zero+" 0");
		print("MOVE "+ind+" 4");
		print("MOVE "+tmp2+" MINUS "+tmp2+" 4");
		print(l1);
		print("MOVE "+tmp+" LE "+ind+" "+tmp2);
		print("CJUMP "+tmp+" "+l2);
		print("MOVE "+elem+" PLUS "+arr.code+" "+ind);
		print("HSTORE "+elem+" 0 "+zero);
		print("MOVE "+ind+" PLUS "+ind+" 4");
		print("JUMP "+l1);
		print(l2);
		print("NOOP");
		code-=5;
		return arr;
	}

	/**   AllocationExpression!!!
	* f0 -> "new"
	* f1 -> Identifier()
	* f2 -> "("
	* f3 -> ")"
	*/
	public retAttr visit(AllocationExpression n, A argu) 
	{
		return createNewClass(n.f1.f0.tokenImage);
	}

	/**   NotExpression!!!
	* f0 -> "!"
	* f1 -> Expression() - boolean
	*/
	public retAttr visit(NotExpression n, A argu) 
	{
		retAttr not = new retAttr(getNewCode(),"boolean");
		String one = getNewCode();
		print("MOVE "+one+" 1");
		print("MOVE "+not.code+" MINUS "+one+" "+n.f1.accept(this,null).code);
		code--;
		return not;
	}

	/**   BracketExpression!!!
	* f0 -> "("
	* f1 -> Expression()
	* f2 -> ")"
	*/
	public retAttr visit(BracketExpression n, A argu) 
	{
		return n.f1.accept(this, null);
	}


	public retAttr visit(IdentifierList n, A argu) {
		return null;
	}
	public retAttr visit(IdentifierRest n, A argu) {
		return null;
	}

}
