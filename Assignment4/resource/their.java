//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

class TempInfo {
	int num;
	int start;
	int end;
	
	public void print() {
		System.out.println(num + " : " + start + " - " + end);
	}
}

class NodeInfo {
	ArrayList<Integer> successor = new ArrayList<>();
	HashSet<Integer> def = new HashSet<>();
	HashSet<Integer> use = new HashSet<>();
	HashSet<Integer> in = new HashSet<>();
	HashSet<Integer> out = new HashSet<>();
	
	public void print() {
		System.out.print("Succesor: ");
		System.out.println(successor);
		System.out.print("Use: ");
		System.out.println(use);
		System.out.print("Def: ");
		System.out.println(def);
		System.out.print("In: ");
		System.out.println(in);
		System.out.print("Out: ");
		System.out.println(out);
	}
}

class FuncInfo {
	int numArgs;
	ArrayList<NodeInfo> nodes = new ArrayList<>();
	ArrayList<TempInfo> temps = new ArrayList<>();
	HashMap<Integer, Integer> tempMap = new HashMap<>();
	HashMap<Integer, String> regMap = new HashMap<>();
	boolean spill = false;
	HashSet<Integer> spilledTemps = new HashSet<>();
	int maxStackSpace = 0, currStackPointer;
	int maxNumArgs = 0;
	int tRegs = 0, sRegs = 0;
	boolean hasCall = false;
	
	public void print() {
		for (int i = 0; i < nodes.size(); i++) {
			System.out.println("------------------------------------");
			System.out.println(i);
			nodes.get(i).print();
			System.out.println("------------------------------------");
		}
	}
	
	public void printRanges() {
		for (int i = 0; i < temps.size(); i++) {
			temps.get(i).print();
		}
	}
	
	public void printRegMap() {
		if(spill) {
			System.out.println("//SPILLED");
		}
		else {
			System.out.println("//NOTSPILLED");
		}
		
		for (Map.Entry<Integer, String> entry : regMap.entrySet()) {
			int tempNo = entry.getKey();
			String reg = regMap.get(tempNo);
			System.out.println("TEMP " + tempNo + " : " + reg);
		}
	}
}

class SS {
	HashMap<String, FuncInfo> liveNodes = new HashMap<>();
	
	public void print() {
		for(Map.Entry<String, FuncInfo> entry : liveNodes.entrySet()) {
			String fName = entry.getKey();
			System.out.println("*****************************************");
			System.out.println(fName);
			liveNodes.get(fName).print();
			System.out.println("*****************************************");
		}
	}
	
	public void printRanges() {
		for(Map.Entry<String, FuncInfo> entry : liveNodes.entrySet()) {
			String fName = entry.getKey();
			System.out.println("*****************************************");
			System.out.println(fName);
			liveNodes.get(fName).printRanges();
			System.out.println("*****************************************");
		}
	}
	
	public void printRegMap() {
		for(Map.Entry<String, FuncInfo> entry : liveNodes.entrySet()) {
			String fName = entry.getKey();
			FuncInfo funcInfo = liveNodes.get(fName);
			System.out.println("*****************************************");
			System.out.print(fName);
			System.out.print(" [ " + funcInfo.numArgs + " ]");
			System.out.print(" [ " + funcInfo.maxStackSpace + " ]");
			System.out.println(" [ " + funcInfo.maxNumArgs + " ]");
			funcInfo.printRegMap();
			System.out.println("*****************************************");
		}
	}
}

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class their<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
	
	int lineCount;
	boolean getLabel;
	SS SS = new SS();
	FuncInfo currFunc;
	NodeInfo currNode;
	String funcName;
	int numCallArgs;
	HashMap<String, Integer> labelLineNum = new HashMap<>();
	HashMap<Integer, String> labelProcess = new HashMap<>();
	boolean firstpass;
	
	private void processLabels() {
		for(Map.Entry<Integer, String> entry : labelProcess.entrySet()) {
			int lineNo = entry.getKey();
			String lab = labelProcess.get(lineNo);
			currFunc.nodes.get(lineNo).successor.add(labelLineNum.get(lab));
		}
	}
	
	private void livenessAnalysis() {
		boolean cont;
		
		for(Map.Entry<String, FuncInfo> entry : SS.liveNodes.entrySet()) {
			String funcName = entry.getKey();
			FuncInfo funcInfo = SS.liveNodes.get(funcName);
			cont = true;
			while(cont) {
				cont = false;
				for (int i = funcInfo.nodes.size() - 1; i >= 0; i--) {
					NodeInfo currNode = funcInfo.nodes.get(i);

					HashSet<Integer> out_store = new HashSet<>(currNode.out);
					HashSet<Integer> in_store = new HashSet<>(currNode.in);
					HashSet<Integer> diff_temp = new HashSet<>(currNode.out);
					diff_temp.removeAll(currNode.def);
					
					currNode.in.clear();
					currNode.in.addAll(diff_temp);
					currNode.in.addAll(currNode.use);
					
					currNode.out.clear();
					for(int j = 0; j < currNode.successor.size(); j++) {
						NodeInfo succNode = funcInfo.nodes.get(currNode.successor.get(j));
						currNode.out.addAll(succNode.in);
					}
					
					if(!currNode.in.equals(in_store) || !currNode.out.equals(out_store)) {
						cont = true;
					}
				}
			}
		}
	}
	
	private void findLiveRange() {
		for(Map.Entry<String, FuncInfo> entry : SS.liveNodes.entrySet()) {
			String funcName = entry.getKey();
			FuncInfo funcInfo = SS.liveNodes.get(funcName);
			NodeInfo currNode;
			int lim = 0;
			
			if(funcInfo.nodes.size() > 0) {
				currNode = funcInfo.nodes.get(0);
				for(Integer it : currNode.in) {
					TempInfo newTemp = new TempInfo();
					newTemp.num = it;
					newTemp.start = 0;
					funcInfo.tempMap.put(it, lim);
					funcInfo.temps.add(newTemp);
					lim++;
				}
			}
			
			for (int i = 0; i < funcInfo.nodes.size(); i++) {
				currNode = funcInfo.nodes.get(i);
				for (Integer it1 : currNode.out) {
					if(!funcInfo.tempMap.containsKey(it1)) {
						TempInfo newTemp = new TempInfo();
						newTemp.num = it1;
						newTemp.start = i;
						funcInfo.tempMap.put(it1, lim);
						funcInfo.temps.add(newTemp);
						lim++;
					}
				}
				
				for(Integer it3 : currNode.def) {
					if(!funcInfo.tempMap.containsKey(it3)) {
						TempInfo newTemp = new TempInfo();
						newTemp.num = it3;
						newTemp.start = i;
						funcInfo.tempMap.put(it3, lim);
						funcInfo.temps.add(newTemp);
						lim++;
					}
				}
				
				for(Integer it2 : currNode.in) {
					int index = funcInfo.tempMap.get(it2);
					funcInfo.temps.get(index).end = i;
				}
			}
		}
	}
	
	private void linearScan() {
		int num_regs = 18;
		boolean[] regs = new boolean[num_regs];
		String[] regNames = {"s0", "s1", "s2", "s3", "s4", "s5",
							"s6", "s7", "t0", "t1", "t2", "t3",
							"t4", "t5", "t6", "t7", "t8", "t9" };
		int next_alloc;
		int stackNum;
		ArrayList<TempInfo> active = new ArrayList<>();
		ArrayList<Integer> toBeSpilled = new ArrayList<>();
		HashMap<Integer, Integer> regNumMap = new HashMap<>();
		
		for(Map.Entry<String, FuncInfo> entry : SS.liveNodes.entrySet()) {
			String funcName = entry.getKey();
			FuncInfo funcInfo = SS.liveNodes.get(funcName);
			stackNum = 0;
			
			for(int i = 0; i < num_regs; i++) {
				regs[i] = true;
			}
			
			ArrayList<TempInfo> liveRanges = new ArrayList<>(funcInfo.temps);
			
			for(int j = 4; j < funcInfo.numArgs; j++) {
				for(int k = 0; k < liveRanges.size(); k++) {
					if(liveRanges.get(k).num == j) {
						liveRanges.remove(k);
						break;
					}
				}
				
				funcInfo.regMap.put(j, "" + stackNum);
				funcInfo.spilledTemps.add(j);
				stackNum++;
			}
			
			Collections.sort(liveRanges, new Comparator<TempInfo>() {

				@Override
				public int compare(TempInfo t1, TempInfo t2) {
					// TODO Auto-generated method stub
					if(t1.start > t2.start)
						return 1;
					else if (t1.start < t2.start)
						return -1;
					else { 
						if(t1.end > t2.end)
							return 1;
						else if(t1.end < t2.end)
							return -1;
						else
							return 0;
					}
				}
					
			});
			
			next_alloc = 0;
			
			for(int i = 0; i < liveRanges.size(); i++) {
				TempInfo currTemp = liveRanges.get(i);
				//expireOldInterval begin
				while(!active.isEmpty() && active.get(0).end < currTemp.start) {
					int currReg = regNumMap.get(active.get(0).num);
					regs[currReg] = true;
					active.remove(0);
				}
				//expireOldInterval end
				
				if(active.size() < num_regs) {
					while (!regs[next_alloc]) {
						next_alloc = (next_alloc+1) % num_regs;
					}
					regNumMap.put(currTemp.num, next_alloc);
					regs[next_alloc] = false;
					next_alloc = (next_alloc+1) % num_regs;
					
					int index = -1;
					while (((++index) < active.size()) &&
							(active.get(index).end < currTemp.end));
					if(index == active.size()) {
						active.add(currTemp);
					}
					else {
						active.add(index, currTemp);
					}
				}
				else {
					//spillAtInterval begin
					TempInfo lastTemp = active.get(active.size() - 1);
					if(lastTemp.end > currTemp.end) {
						regNumMap.put(currTemp.num, regNumMap.get(lastTemp.num));
						regNumMap.remove(lastTemp.num);
						
						toBeSpilled.add(lastTemp.num);
						funcInfo.spill = true;
						funcInfo.spilledTemps.add(lastTemp.num);
						active.remove(active.size() - 1);
						
						int index = -1;
						while (((++index) < active.size()) &&
								(active.get(index).end < currTemp.end));
						if(index == active.size()) {
							active.add(currTemp);
						}
						else {
							active.add(index, currTemp);
						}
					}
					else {
						funcInfo.spill = true;
						funcInfo.spilledTemps.add(currTemp.num);
						toBeSpilled.add(currTemp.num);
					}
					//spillAtInterval end
				}
			}
			
			for(Map.Entry<Integer, Integer> el : regNumMap.entrySet()) {
				int tempNo = el.getKey();
				int regNo = regNumMap.get(tempNo);
				funcInfo.regMap.put(tempNo, regNames[regNo]);
			}
			
			for(int l = 0; l < toBeSpilled.size(); l++) {
				funcInfo.regMap.put(toBeSpilled.get(l), ""+stackNum);
				stackNum++;
			}
			

			//Clear
			active.clear();
			regNumMap.clear();
			toBeSpilled.clear();
			
			//Miscellaneous
			int numSReg = funcInfo.regMap.size();
			if(funcInfo.numArgs > 4) {
				numSReg -= (funcInfo.numArgs - 4);
			}
			int numTReg;
			
			if(numSReg >= 18) {
				numSReg = 8;
				numTReg = 10;
			}
			else if(numSReg >= 8) {
				numTReg = numSReg - 8;
				numSReg = 8;
			}
			else {
				numTReg = 0;
			}
			
			funcInfo.currStackPointer = stackNum;
			
			if(!funcName.equals("MAIN")) {
				stackNum += numSReg;
			}
			
			funcInfo.maxStackSpace += stackNum;
			if(funcInfo.maxNumArgs > 4) {
				funcInfo.maxStackSpace += (funcInfo.maxNumArgs - 4);
			}
			
			if(funcInfo.hasCall) {
				funcInfo.maxStackSpace += numTReg;
			}
			funcInfo.tRegs = numTReg;
			funcInfo.sRegs = numSReg;
			
		}
	}
	
	private void translateTemp(int tempNo, boolean spilled, boolean use, boolean v0) {
		if(!spilled) {
			String reg = currFunc.regMap.get(tempNo);
			System.out.print(reg);
		}
		
		else {
			String stackOffset = currFunc.regMap.get(tempNo);
			if(use) {
				System.out.print("ALOAD ");
				if(v0) {
					System.out.print("v0");
				}
				else {
					System.out.print("v1");
				}
				
				System.out.println(" SPILLEDARG " + stackOffset);
			}
			
			else {
				System.out.print("ASTORE ");
				System.out.print(" SPILLEDARG " + stackOffset);
				if(v0) {
					System.out.println(" v0");
				}
				else {
					System.out.println(" v1");
				}
			}
		}
	}
	
	private void initSetup() {
		for(int i = 0;  i < currFunc.numArgs; i++) {
			if(currFunc.spilledTemps.contains(i)) {
				System.out.println("MOVE v0 a" + i);
				translateTemp(i, true, false, true);
			}
			else {
				if(currFunc.regMap.containsKey(i)) {
					System.out.print("MOVE ");
					translateTemp(i, false, false, true);
					System.out.println(" a" + i);
				}
			}
			
			if(i == 3)
				break;
		}
	}
	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      funcName = (String)n.f0.accept(this, argu);
      if(firstpass) {
    	  currFunc = new FuncInfo();
      }
      else {
    	  currFunc = SS.liveNodes.get(funcName);
      }
      
      n.f1.accept(this, argu);
      String str = (String)n.f2.accept(this, argu);
      
      if(firstpass) {
    	  currFunc.numArgs = Integer.parseInt(str);
          lineCount = 0;
      }
      
      if(!firstpass) {
    	  System.out.print(funcName);
    	  System.out.print(" [ " + currFunc.numArgs + " ]");
    	  System.out.print(" [ " + currFunc.maxStackSpace + " ]");
    	  System.out.print(" [ " + currFunc.maxNumArgs + " ]");
    	  System.out.println();
      }
      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      if(firstpass) {
    	  processLabels();
    	  labelProcess.clear();
    	  labelLineNum.clear();
    	  SS.liveNodes.put(funcName, currFunc);
      }
      
      return _ret;
   }

//
   // User-generated visitor methods below
   //

   /** >Goal ::= MAIN StmtList() END ( Procedure() )* <EOF>
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      currFunc = new FuncInfo();
      lineCount = 0;
      currFunc.numArgs = 0;
      firstpass = true;
      funcName = "MAIN";
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      if(lineCount > 0) {
    	  currFunc.nodes.get(lineCount - 1).successor.clear();
      }
      
      processLabels();
      labelProcess.clear();
      labelLineNum.clear();
      SS.liveNodes.put("MAIN", currFunc);
      
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      
      livenessAnalysis();
      findLiveRange();
      linearScan();
      
      firstpass = false;
      currFunc = SS.liveNodes.get("MAIN");
	  System.out.print("MAIN");
	  System.out.print(" [ " + currFunc.numArgs + " ]");
	  System.out.print(" [ " + currFunc.maxStackSpace + " ]");
	  System.out.print(" [ " + currFunc.maxNumArgs + " ]");
	  System.out.println();
      funcName = "MAIN";
	  
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      System.out.println("END");
	  if(currFunc.spill) {
		  System.out.println("//SPILLED");
	  }
	  else {
		  System.out.println("//NOTSPILLED");
	  }
	  System.out.println();
	  
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      
      return _ret;
   }

   /** >StmtList ::= ( ( Label() )? Stmt() )*
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      getLabel = true;
      n.f0.accept(this, argu);
      getLabel = false;
      return _ret;
   }

   /** >Stmt
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      if(firstpass) {
    	  currNode = new NodeInfo();
      }
	  getLabel = false;      
      n.f0.accept(this, argu);
      
      if(firstpass) {
    	  currFunc.nodes.add(currNode);
    	  lineCount++;
      }
	  getLabel = true;
      
      return _ret;
   }

   /** >NoOpStmt ::= NOOP
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(firstpass) {
    	  currNode.successor.add(lineCount+1);
      }
      else {
    	  System.out.println("NOOP");
      }
      return _ret;
   }

   /** >ErrorStmt ::= ERROR
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(!firstpass) {
    	  System.out.println("ERROR");
      }
      return _ret;
   }

   /** >CJumpStmt ::= CJUMP Temp() Label()
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String temp = (String)n.f1.accept(this, argu);
      String lab = (String)n.f2.accept(this, argu);
      
      if (firstpass) {
    	  currNode.use.add(Integer.parseInt(temp));
          currNode.successor.add(lineCount+1);
          if(labelLineNum.containsKey(lab)) {
        	  currNode.successor.add(labelLineNum.get(lab));
          }
          else {
        	  labelProcess.put(lineCount, lab);
          }
      }
      else {
    	  if(currFunc.spilledTemps.contains(Integer.parseInt(temp))) {
    		  translateTemp(Integer.parseInt(temp), true, true, true);
    		  System.out.println("CJUMP v0 " + lab);
    	  }
    	  else {
    		  int t = Integer.parseInt(temp);
			  System.out.print("CJUMP ");
			  translateTemp(t, false, true, true);
			  System.out.println(" " + funcName + "_" + lab);
    	  }
      }
      return _ret;
   }

   /** >JumpStmt ::= JUMP Label()
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String lab = (String)n.f1.accept(this, argu);
      if(firstpass) {
    	  if(labelLineNum.containsKey(lab)) {
        	  currNode.successor.add(labelLineNum.get(lab));
          }
          else {
        	  labelProcess.put(lineCount, lab);
          }
      }
      else {
    	  System.out.println("JUMP " + funcName + "_" + lab);
      }
      return _ret;
   }

   /** >HStoreStmt ::= HSTORE Temp() IntegerLiteral() Temp()
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String temp1 = (String)n.f1.accept(this, argu);
      String num = (String)n.f2.accept(this, argu);
      String temp2 = (String)n.f3.accept(this, argu);
      if (firstpass) {
    	  currNode.use.add(Integer.parseInt(temp1));
          currNode.use.add(Integer.parseInt(temp2));
          currNode.successor.add(lineCount+1);
      }
      else {
    	  int t1 = Integer.parseInt(temp1);
    	  int t2 = Integer.parseInt(temp2);
    	  
    	  if(currFunc.spilledTemps.contains(t2)) {
    		  translateTemp(t2, true, true, true);
    		  if(currFunc.spilledTemps.contains(t1)) {
    			  translateTemp(t1, true, true, false);
    			  System.out.println("HSTORE v1 " + num + " v0");
    		  }
    		  else {
				  System.out.print("HSTORE ");
				  translateTemp(t1, false, true, false);
				  System.out.println(" " + num + " v0");
    		  }
    	  }
    	  else {
    		  if(currFunc.spilledTemps.contains(t1)) {
    			  translateTemp(t1, true, true, false);
    			  System.out.print("HSTORE v1 " + num + " ");
    			  translateTemp(t2, false, true, true);
    			  System.out.println();
    		  }
    		  else {
    			  System.out.print("HSTORE ");
    			  translateTemp(t1, false, true, false);
    			  System.out.print(" " + num + " ");
    			  translateTemp(t2, false, true, true);
    			  System.out.println();
    		  }
    	  }
      }
      return _ret;
   }

   /** >HLoadStmt ::= HLOAD Temp() Temp() IntegerLiteral()
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String temp1 = (String)n.f1.accept(this, argu);
      String temp2 = (String)n.f2.accept(this, argu);
      String num = (String)n.f3.accept(this, argu);
      
      if (firstpass) {
    	  currNode.def.add(Integer.parseInt(temp1));
          currNode.use.add(Integer.parseInt(temp2));
          currNode.successor.add(lineCount+1);
      }
      else {
    	  int t1 = Integer.parseInt(temp1);
    	  int t2 = Integer.parseInt(temp2);
    	  
    	  if(currFunc.spilledTemps.contains(t2)) {
    		  translateTemp(t2, true, true, true);
    		  if(currFunc.spilledTemps.contains(t1)) {
    			  System.out.println("HLOAD v1 v0 " + num);
    			  translateTemp(t1, true, false, false);
    		  }
    		  else {
    			  if(currFunc.regMap.containsKey(t1)) {
        			  System.out.print("HSTORE ");
        			  translateTemp(t1, false, false, false);
        			  System.out.println(" v0 " + num);
    			  }
    		  }
    	  }
    	  else {
			  if(currFunc.spilledTemps.contains(t1)) {
    			  System.out.print("HLOAD v1 ");
    			  translateTemp(t2, false, true, true);
    			  System.out.println(" " + num);
    			  translateTemp(t1, true, false, false);
    			  System.out.println();
    		  }
    		  else {
    			  if(currFunc.regMap.containsKey(t1)) {
    				  System.out.print("HLOAD ");
        			  translateTemp(t1, false, false, false);
        			  System.out.print(" ");
        			  translateTemp(t2, false, true, true);
        			  System.out.println(" " + num);
    			  }
    		  }
    	  }
      }
      return _ret;
   }

   /** >MoveStmt ::= MOVE Temp() Exp()
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String temp = (String)n.f1.accept(this, argu);
      String exp = (String)n.f2.accept(this, argu);
      if (firstpass) {
          currNode.def.add(Integer.parseInt(temp));
          currNode.successor.add(lineCount+1);
      }
      else {
    		  int t = Integer.parseInt(temp);
        	  if(currFunc.spilledTemps.contains(t)) {
        		  System.out.println("MOVE v1 " + exp);
        		  translateTemp(t, true, false, false);
        	  }
        	  else {
        		  if(currFunc.regMap.containsKey(t)) {
        			  System.out.print("MOVE ");
        			  translateTemp(t, false, false, false);
        			  System.out.println(" " + exp);
        		  }
        	  }
      }
      return _ret;
   }

   /** >PrintStmt ::= PRINT SimpleExp()
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String simpExp = (String)n.f1.accept(this, argu);
      if(firstpass) {
    	  currNode.successor.add(lineCount+1);
      }
      else {
    	  System.out.println("PRINT " + simpExp);
      }
      
      return _ret;
   }

   /** >Exp
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /** >StmtExp
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      int sPointer = 0;
      if(!firstpass) {
    	  sPointer = currFunc.currStackPointer;
    	  for (int i = 0; i < currFunc.sRegs; i++) {
    		  System.out.println("ASTORE SPILLEDARG " + sPointer + " s" + i);
    		  sPointer++;
    	  }
    	  currFunc.currStackPointer = sPointer;
    	  initSetup();
      }
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      if (firstpass) {
    	  currNode = new NodeInfo();
      }
      
      String retVal = (String)n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      if(firstpass) {
    	  currFunc.nodes.add(currNode);
      }
      else {
    	  System.out.println("MOVE v0 " + retVal);
    	  for (int i = currFunc.sRegs - 1; i >= 0; i--) {
    		  System.out.println("ALOAD s" + i + " SPILLEDARG " + (--sPointer));
    	  }
    	  currFunc.currStackPointer = sPointer;
    	  System.out.println("END");
    	  if(currFunc.spill) {
    		  System.out.println("//SPILLED");
    	  }
    	  else {
    		  System.out.println("//NOTSPILLED");
    	  }
    	  System.out.println();
      }
      return _ret;
   }

   /** >Call
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      if(firstpass) {
    	  currFunc.hasCall = true;
      }
      
      n.f0.accept(this, argu);
      String callFunc = (String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      int tPointer = 0;
      if(!firstpass) {
    	  tPointer = currFunc.currStackPointer;
    	  for(int i = 0; i < currFunc.tRegs; i++) {
    		  System.out.println("ASTORE SPILLEDARG " + tPointer + " t" + i);
    		  tPointer++;
    	  }
    	  currFunc.currStackPointer = tPointer;
      }
      numCallArgs = 0;
      n.f3.accept(this, (A)"CALL");
      n.f4.accept(this, argu);
      if(firstpass) {
    	  if(currFunc.maxNumArgs < numCallArgs) {
        	  currFunc.maxNumArgs = numCallArgs;
          }
      }
      else {
    	  System.out.println("CALL " + callFunc);
    	  for(int i = currFunc.tRegs - 1; i >= 0; i--) {
    		  System.out.println("ALOAD t" + i + " SPILLEDARG " + (--tPointer));
    	  }
    	  currFunc.currStackPointer = tPointer;
      }
      _ret = (R)"v0";
      return _ret;
   }

   /** >HAllocate ::= HALLOCATE SimpleExp()
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String simpExp = (String)n.f1.accept(this, argu);
      _ret = (R) ("HALLOCATE " + simpExp);
      if(!firstpass) {
    	  if(simpExp.charAt(0) <= '9') {
    		  System.out.println("MOVE v1 " + simpExp);
    		  System.out.println("MOVE v0 PLUS v1 4");
    	  }
    	  else {
    		  System.out.println("MOVE v0 PLUS " + simpExp + " 4");
    	  }
    	  _ret = (R) "HALLOCATE v0";
      }
      return _ret;
   }

   /** >BinOp ::= Operator Temp() SimpleExp()
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      String op = (String)n.f0.accept(this, argu);
      String temp = (String)n.f1.accept(this, argu);
      if(firstpass) {
    	  currNode.use.add(Integer.parseInt(temp));
      }
      
      String simpExp = (String)n.f2.accept(this, argu);
      if (!firstpass) {
    	  int t = Integer.parseInt(temp);
    	  if(currFunc.spilledTemps.contains(t)) {
    		  translateTemp(t, true, false, true);
    		  temp = "v0";
    	  }
    	  else {
    		  temp = currFunc.regMap.get(t);
    	  }
      }
	  _ret = (R) (op + " " + temp + " " + simpExp);
      return _ret;
   }

   /** >Operator ::= LE|NE|PLUS|MINUS|TIMES|DIVIDE
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /** >SimpleExp() ::= Temp() | IntegerLiteral() | Label()
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      String str = (String)n.f0.accept(this, argu);
      if(firstpass) {
    	  if(n.f0.which == 0) {
        	  currNode.use.add(Integer.parseInt(str));
          }
      }
      else {
    	  if(n.f0.which == 0) {
    		  if(currFunc.spilledTemps.contains(Integer.parseInt(str))) {
    			  translateTemp(Integer.parseInt(str), true, true, false);
    			  str = "v1";
    		  }
    		  else {
    			  str = currFunc.regMap.get(Integer.parseInt(str));
    		  }
    	  }
      }
      _ret = (R)str;
      return _ret;
   }

   /** >Temp() ::= "TEMP" IntegerLiteral()
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String temp = (String)n.f1.accept(this, argu);
      if(firstpass) {
    	  if(argu != null) {
        	  currNode.use.add(Integer.parseInt(temp));
        	  numCallArgs++;
          }
      }
      else {
    	  if(argu != null) {
    		  int t = Integer.parseInt(temp);
    		  String trans; 
    		  if(currFunc.spilledTemps.contains(t)) {
    			  translateTemp(t, true, true, true);
    			  trans = "v0";
    		  }
    		  else {
    			  trans = currFunc.regMap.get(t);
    		  }
    		  
    		  if(numCallArgs < 4) {
    			  System.out.println("MOVE a" + numCallArgs + " " + trans);
    		  }
    		  else {
    			  System.out.println("PASSARG " + (numCallArgs - 3) + " " + trans);
    		  }
    		  numCallArgs++;
    	  }
      }
      
      _ret = (R)temp;
      return _ret;
   }

   /** >IntegerLiteral() ::= <INTEGER_LITERAL>
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret = n.f0.accept(this, argu);
      return _ret;
   }

   /** >Label() ::= <IDENTIFIER>
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      String lab = (String)n.f0.accept(this, argu);
      if(firstpass) {
    	  if(getLabel) {
        	  labelLineNum.put(lab, lineCount);
          }
      }
      else {
    	  if(getLabel) {
    		  System.out.print(funcName + "_" + lab + " ");
    	  }
      }
      
      _ret = (R)lab;
      return _ret;
   }

}