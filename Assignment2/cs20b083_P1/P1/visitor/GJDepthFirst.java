//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {

	int debug = 0;
	int visit = 0;
	String curClass;

	private void typeError()
	{
		System.out.println("Type error");
		System.exit(1);
	}

	class varAttr {
		String type;
		varAttr(String type) {
			this.type = type;
		}
	}

	class argAttr {
		Map<String, varAttr> argMap;
		ArrayList<String> argType;
		argAttr() {
			argMap = new HashMap<String, varAttr>();
			argType = new ArrayList<String>();
		}
	}
	class methAttr {
		String type;
		String retExp;
		Map<String, varAttr> varMap;
		argAttr arg;
		methAttr(String type) {
			this.type = type;
			varMap = new HashMap<String, varAttr>();
			arg = new argAttr();
		}
	}

	class classAttr {
		boolean isChild;
		ArrayList<String> parentList;
		Map<String, varAttr> varMap;
		Map<String, methAttr> methMap;
		//default constructor
		classAttr() {
			isChild = false;
			parentList = new ArrayList<String>();
			varMap = new HashMap<String, varAttr>();
			methMap = new HashMap<String, methAttr>();
		}
	}

	private Map<String, classAttr> classTable = new HashMap<String, classAttr>();
	private Map<String, Stack<String>> varTypeMap = new HashMap<String, Stack<String>>();

	private boolean checkParents(String child, String parent)
	{
		final Set<String> basic = Set.of("int","boolean","int[]");
		if(basic.contains(child) || basic.contains(parent))
		{
			return child.equals(parent);
		}

		if(child.equals(parent)) return true;

		classAttr cattr = classTable.get(child);
		
		for (String pname : cattr.parentList) {
			if(pname.equals(parent))
			{
				return true;
			}
			else if(checkParents(pname, parent)) return true;
		}
		return false;
	}

	private boolean getMeth(String mname, String cname)
	{
		if(classTable.get(cname).methMap.containsKey(mname)) return true;

		for(String par: classTable.get(cname).parentList)
		{
			cname = par;
			getMeth(mname, par);
		}
		return false;
	}

	private boolean sameMethod(methAttr cmeth, methAttr pmeth)
	{
		if(cmeth.arg.argMap.size() == pmeth.arg.argMap.size())
		{
			for(int i=0;i<cmeth.arg.argMap.size();i++)
			{
				if(!cmeth.arg.argType.get(i).equals(pmeth.arg.argType.get(i)))
				{
					return false;
				}
			}
		}
		else return false;
		
		if(cmeth.type.equals(pmeth.type)) return true;
		return false;
	}

	private boolean overloadingHelper(String cname, String pname)
	{
		for(String meth:classTable.get(cname).methMap.keySet())
		{
			if(classTable.get(pname).methMap.containsKey(meth))
			{
				if(!sameMethod(classTable.get(cname).methMap.get(meth), classTable.get(pname).methMap.get(meth)))
				{
					return false;
				}
			}
		}

		return noOverloading(pname);
	}

	private boolean noOverloading(String cname)
	{
		for(String par: classTable.get(cname).parentList)
		{
			if(!overloadingHelper(cname, par)) 
			{
				return false;
			}
		}
		return true;
	}

	private boolean checkCycle()
	{
		Map<String, Integer> classes = new HashMap<String, Integer>();
		int c=0;
		for(String cname: classTable.keySet())
		{
			if(!addClassCycle(cname, c++, classes)) return false;
		}
		return true;
	}

	private boolean addClassCycle(String cname, int c, Map<String, Integer> classes)
	{
		if(classes.containsKey(cname))
		{
			if(classes.get(cname)==c) return false;
		}
		else
		{
			classes.put(cname,c);
			for(String par: classTable.get(cname).parentList)
			{
				if(!addClassCycle(par, c, classes))
					return false;
			}
		}
		return true;
	}
	
	private boolean checkParentExists()
	{
		for(String cname: classTable.keySet())
		{
			for(String par: classTable.get(cname).parentList)
			{
				if(!classTable.containsKey(par))
				{
					return false;
				}
			}
		}
		return true;
	}

	private boolean checkOverload()
	{
		for(String cname: classTable.keySet())
		{
			if(!noOverloading(cname))
			{
				return false;
			}
		}
		return true;
	}

	private boolean checkDependencies()
	{
		if(!checkParentExists()) return false;
		if(!checkCycle() || !checkOverload()) return false;
		return true;
	}

	// Auto class visitors--probably don't need to be overridden.

	public R visit(NodeList n, A argu) {
		R _ret=null;
		int _count=0;
		for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
			e.nextElement().accept(this,argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeListOptional n, A argu) {
		if ( n.present() ) {
			R _ret=null;
			int _count=0;
			for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
				e.nextElement().accept(this,argu);
				_count++;
			}
			return _ret;
		}
		else
			return null;
	}

	public R visit(NodeOptional n, A argu) {
		if ( n.present() )
			return n.node.accept(this,argu);
		else
			return null;
	}

	public R visit(NodeSequence n, A argu) {
		R _ret=null;
		int _count=0;
		for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
			e.nextElement().accept(this,argu);
			_count++;
		}
		return _ret;
	}

	public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

	//
	// User-generated visitor methods below
	//

	/** Goal!!!
		* f0 -> MainClass()
		* f1 -> ( TypeDeclaration() )*
		* f2 -> <EOF>
		*/
	public R visit(Goal n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		if(!checkDependencies())
		{
			typeError();
		}
		visit = 1;
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		n.f2.accept(this, null);
		System.out.println("Program type checked successfully");
		return null;
	}

	/** MainClass!!!
		* f0 -> "class"
		* f1 -> Identifier()
		* f2 -> "{"
		* f3 -> "public"
		* f4 -> "static"
		* f5 -> "void"
		* f6 -> "main"
		* f7 -> "("
		* f8 -> "String"
		* f9 -> "["
		* f10 -> "]"
		* f11 -> Identifier()
		* f12 -> ")"
		* f13 -> "{"
		* f14 -> PrintStatement()
		* f15 -> "}"
		* f16 -> "}"
		*/
	public R visit(MainClass n, A argu) 
	{
		classAttr cattr = new classAttr();
		
		n.f0.accept(this, null);
		String cname = (String)n.f1.accept(this, null);
		n.f2.accept(this, null);
		n.f3.accept(this, null);
		n.f4.accept(this, null);
		n.f5.accept(this, null);
		n.f6.accept(this, null);
		n.f7.accept(this, null);
		n.f8.accept(this, null);
		n.f9.accept(this, null);
		n.f10.accept(this, null);
		n.f11.accept(this, null);
		n.f12.accept(this, null);
		n.f13.accept(this, null);
		n.f14.accept(this, null);
		n.f15.accept(this, null);
		n.f16.accept(this, null);
		if(visit==0) classTable.put(cname, cattr);
		return null;
	}

	/**   TypeDeclaration!!!
		* f0 -> ClassDeclaration()
		*       | ClassExtendsDeclaration()
		*/
	public R visit(TypeDeclaration n, A argu) 
	{
		n.f0.accept(this, null);
		return null;
	}

	/**   ClassDeclaration!!!
		* f0 -> "class"
		* f1 -> Identifier()
		* f2 -> "{"
		* f3 -> ( VarDeclaration() )*
		* f4 -> ( MethodDeclaration() )*
		* f5 -> "}"
		*/
	public R visit(ClassDeclaration n, A argu) 
	{
		classAttr cattr = new classAttr();

		n.f0.accept(this, null);
		String cname = (String)n.f1.accept(this, null);
		curClass = cname;
		if(visit==0 && classTable.containsKey(cname))
		{
			typeError();
		}
		n.f2.accept(this, null);
		n.f3.accept(this, (A)cattr.varMap);
		n.f4.accept(this, (A)cattr.methMap);
		n.f5.accept(this, null);
		if(visit==0) 
		{
			classTable.put(cname, cattr);
		}
		else for(String var:cattr.varMap.keySet()) varTypeMap.get(var).pop();
		return null;
	}

	/**   ClassExtendsDeclaration!!!
		* f0 -> "class"
		* f1 -> Identifier()
		* f2 -> "extends"
		* f3 -> Identifier()
		* f4 -> "{"
		* f5 -> ( VarDeclaration() )*
		* f6 -> ( MethodDeclaration() )*
		* f7 -> "}"
		*/
	public R visit(ClassExtendsDeclaration n, A argu) 
	{
		classAttr cattr = new classAttr();
		n.f0.accept(this, null);
		String cname = (String)n.f1.accept(this, null);
		curClass = cname;
		if(visit==0 && classTable.containsKey(cname))
		{
			typeError();
		}
		n.f2.accept(this, null);
		String parName = (String)n.f3.accept(this, null);
		cattr.parentList.add(parName);
		n.f4.accept(this, null);
		n.f5.accept(this, (A)cattr.varMap);
		n.f6.accept(this, (A)cattr.methMap);
		n.f7.accept(this, null);
		if(visit==0)
		{
			classTable.put(cname, cattr);
		}
		else for(String var:cattr.varMap.keySet()) varTypeMap.get(var).pop();
		return null;
	}

	/**   VarDeclaration!!!
		* f0 -> Type()
		* f1 -> Identifier()
		* f2 -> ";"
		*/
	public R visit(VarDeclaration n, A argu) 
	{
		Map<String, varAttr> vmap = (Map<String, varAttr>)argu;
		String vtype = (String)n.f0.accept(this, null);
		String vname = (String)n.f1.accept(this, null);
		if(visit==0) 
		{
			if(vmap.containsKey(vname))
			{
				typeError();
			}
			vmap.put(vname,new varAttr(vtype));
		}
		else
		{  
			if(!varTypeMap.containsKey(vname)) varTypeMap.put(vname,new Stack<String>());
			varTypeMap.get(vname).push(vtype);
		}
		n.f2.accept(this, null);
		return null;
	}

	/**   MethodDeclaration!!!
		* f0 -> "public"
		* f1 -> Type()
		* f2 -> Identifier()
		* f3 -> "("
		* f4 -> ( FormalParameterList() )?
		* f5 -> ")"
		* f6 -> "{"
		* f7 -> ( VarDeclaration() )*
		* f8 -> ( Statement() )*
		* f9 -> "return"
		* f10 -> Expression()
		* f11 -> ";"
		* f12 -> "}"
		*/
	public R visit(MethodDeclaration n, A argu) 
	{
		Map<String,methAttr> mmap = (Map<String,methAttr>)argu;
		n.f0.accept(this, null);
		String rtype = (String)n.f1.accept(this, null);
		String mname = (String)n.f2.accept(this, null);
		methAttr mattr = new methAttr(rtype);
		n.f3.accept(this, null);
		n.f4.accept(this, (A)mattr.arg);
		n.f5.accept(this, null);
		n.f6.accept(this, null);
		n.f7.accept(this, (A)mattr.varMap);
		n.f8.accept(this, null);
		n.f9.accept(this, null);
		mattr.retExp = (String)n.f10.accept(this, null);
		n.f11.accept(this, null);
		n.f12.accept(this, null);
		if(visit==0) 
		{
			if(mmap.containsKey(mname))
			{
				typeError();
			}
			mmap.put(mname,mattr);
		}
		else
		{
			if(!rtype.equals(mattr.retExp))
			{
				typeError();
			}
			for(String var:mattr.varMap.keySet()) varTypeMap.get(var).pop();
			for(String var:mattr.arg.argMap.keySet()) varTypeMap.get(var).pop();
		}
		return null;
	}

	/**   FormalParameterList!!!
		* f0 -> FormalParameter()
		* f1 -> ( FormalParameterRest() )*
		*/
	public R visit(FormalParameterList n, A argu) 
	{
		n.f0.accept(this, argu);
		n.f1.accept(this, argu);
		return null;
	}

	/**   FormalParameter!!!
		* f0 -> Type()
		* f1 -> Identifier()
		*/
	public R visit(FormalParameter n, A argu) 
	{
		String vtype = (String)n.f0.accept(this, null);
		String vname = (String)n.f1.accept(this, null);
		if(visit==0)
		{
			argAttr arg = (argAttr)argu;
			if(arg.argMap.containsKey(vname))
			{
				typeError();
			}

			arg.argMap.put(vname,new varAttr(vtype));
			arg.argType.add(vtype);
		}
		else
		{
			if(!varTypeMap.containsKey(vtype)) varTypeMap.put(vname,new Stack<String>());
			varTypeMap.get(vname).push(vtype);
		}
		return null;
	}

	/**   FormalParameterRest!!!
		* f0 -> ","
		* f1 -> FormalParameter()
		*/
	public R visit(FormalParameterRest n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, argu);
		return null;
	}

	/**   Type!!!
		* f0 -> ArrayType()
		*       | BooleanType()
		*       | IntegerType()
		*       | Identifier()
		*/
	public R visit(Type n, A argu) 
	{
		final Set<String> basic = Set.of("int","boolean","int[]");
		String id = (String)n.f0.accept(this, null);
		if(!basic.contains(id))
		{
			if(visit!=0)
			{
				if(!classTable.containsKey(id))
				{
					typeError();
				}
			}
		}
		return (R)id;
	}

	/**   ArrayType!!!
		* f0 -> "int"
		* f1 -> "["
		* f2 -> "]"
		*/
	public R visit(ArrayType n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		n.f2.accept(this, null);
		return (R)"int[]";
	}

	/**   BooleanType!!!
		* f0 -> "boolean"
		*/
	public R visit(BooleanType n, A argu) 
	{
		n.f0.accept(this, null);
		return (R)"boolean";
	}

	/**   IntegerType!!!
		* f0 -> "int"
		*/
	public R visit(IntegerType n, A argu) {
			/* YOUR CODE HERE */

		n.f0.accept(this, null);
		return (R)"int";
	}

	/**   Statement!!!
		* f0 -> Block()
		*       | AssignmentStatement()
		*       | ArrayAssignmentStatement()
		*       | IfStatement()
		*       | WhileStatement()
		*       | PrintStatement()
		*/
	public R visit(Statement n, A argu) 
	{
		n.f0.accept(this, null);
		return null;
	}

	/**   Block!!!
		* f0 -> "{"
		* f1 -> ( Statement() )*
		* f2 -> "}"
		*/
	public R visit(Block n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		n.f2.accept(this, null);
		return null;
	}

	/**   AssignmentStatement!!!
		* f0 -> Identifier()
		* f1 -> "="
		* f2 -> Expression()
		* f3 -> ";"
		*/
	public R visit(AssignmentStatement n, A argu)
	{
		String vname = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String etype = (String)n.f2.accept(this, null);
		n.f3.accept(this, null);

		if(visit!=0)
		{
			if(varTypeMap.containsKey(vname))
			{
				String vtype = varTypeMap.get(vname).peek();
				if(!checkParents(etype,vtype))
				{
					typeError();
				}
			}
			else
			{
				typeError();
			}
		}
		return null;
	}

	/**   ArrayAssignmentStatement!!!
		* f0 -> Identifier() - int[]
		* f1 -> "["
		* f2 -> Expression() - int
		* f3 -> "]"
		* f4 -> "="
		* f5 -> Expression() - int
		* f6 -> ";"
		*/
	public R visit(ArrayAssignmentStatement n, A argu) 
	{
		String vname = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String etype1 = (String)n.f2.accept(this, null);
		n.f3.accept(this, null);
		n.f4.accept(this, null);
		String etype2 = (String)n.f5.accept(this, null);
		n.f6.accept(this, null);

		if(visit!=0)
		{
			if(varTypeMap.containsKey(vname))
			{
				String vtype = varTypeMap.get(vname).peek();
				if(!vtype.equals("int[]") || !etype1.equals("int") || !etype2.equals("int"))
				{
					typeError();
				}
			}
			else
			{
				typeError();
			}
		}
		return null;
	}

	/**   IfStatement!!!
		* f0 -> IfthenElseStatement()
		*       | IfthenStatement()
		*/
	public R visit(IfStatement n, A argu) 
	{
		n.f0.accept(this, null);
		return null;
	}

	/**   IfthenElseStatement!!!
		* f0 -> "if"
		* f1 -> "("
		* f2 -> Expression() - boolean
		* f3 -> ")"
		* f4 -> Statement()
		*/
	public R visit(IfthenStatement n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		String etype =(String)n.f2.accept(this, null);
		n.f3.accept(this, null);
		n.f4.accept(this, null);

		if(visit!=0)
		{
			if(!etype.equals("boolean"))
			{
				typeError();
			}
		}
		return null;
	}

	/**   IfthenStatement!!!
		* f0 -> "if"
		* f1 -> "("
		* f2 -> Expression() - boolean
		* f3 -> ")"
		* f4 -> Statement()
		* f5 -> "else"
		* f6 -> Statement()
		*/
	public R visit(IfthenElseStatement n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		String etype =(String)n.f2.accept(this, null);
		n.f3.accept(this, null);
		n.f4.accept(this, null);
		n.f5.accept(this, null);
		n.f6.accept(this, null);

		if(visit!=0)
		{
			if(!etype.equals("boolean"))
			{
				typeError();
			}
		}
		return null;
	}

	/**   WhileStatement!!!
		* f0 -> "while"
		* f1 -> "("
		* f2 -> Expression() - boolean
		* f3 -> ")"
		* f4 -> Statement()
		*/
	public R visit(WhileStatement n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		String etype =(String)n.f2.accept(this, null);
		n.f3.accept(this, null);
		n.f4.accept(this, null);

		if(visit!=0) 
		{
			if(!etype.equals("boolean"))
			{
				typeError();
			}
		}
		return null;
	}

	/**   PrintStatement!!!
		* f0 -> "System.out.println"
		* f1 -> "("
		* f2 -> Expression() - int
		* f3 -> ")"
		* f4 -> ";"
		*/
	public R visit(PrintStatement n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		String etype =(String)n.f2.accept(this, null);
		n.f3.accept(this, null);
		n.f4.accept(this, null);
		if(visit!=0)
		{
			if(!etype.equals("int"))
			{
				typeError();
			}
		}
		return null;
	}

	/**   Expression!!!
		* f0 -> OrExpression()
		*       | AndExpression()
		*       | CompareExpression()
		*       | neqExpression()
		*       | PlusExpression()
		*       | MinusExpression()
		*       | TimesExpression()
		*       | DivExpression()
		*       | ArrayLookup()
		*       | ArrayLength()
		*       | MessageSend()
		*       | PrimaryExpression()
		*/
	public R visit(Expression n, A argu) 
	{	
		String etype = (String) n.f0.accept(this, null);
		return (R)etype;
	}

	/**   AndExpression!!!
		* f0 -> PrimaryExpression() - boolean
		* f1 -> "&&"
		* f2 -> PrimaryExpression() - boolean
		*/
	public R visit(AndExpression n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("boolean") || !t2.equals("boolean"))
			{
				typeError();
			}
		}
		return (R)"boolean";
	}

	/**   OrExpression!!!
		* f0 -> PrimaryExpression() - boolean
		* f1 -> "||"
		* f2 -> PrimaryExpression() - boolean
		*/
	public R visit(OrExpression n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("boolean") || !t2.equals("boolean"))
			{
				typeError();
			}
		}
		return (R)"boolean";
	}

	/**   CompareExpression!!!
		* f0 -> PrimaryExpression() - int
		* f1 -> "<="
		* f2 -> PrimaryExpression() - int
		*/
	public R visit(CompareExpression n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("int") || !t2.equals("int"))
			{
				typeError();
			}
		}
		return (R)"boolean";
	}

	/**   neqExpression!!!
		* f0 -> PrimaryExpression() - t
		* f1 -> "!="
		* f2 -> PrimaryExpression() - t
		*/
	public R visit(neqExpression n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals(t2) || (!t1.equals("int") && !t1.equals("boolean")))
			{
				typeError();
			}
		}
		return (R)"boolean";
	}

	/**   PlusExpression!!!
		* f0 -> PrimaryExpression() - int
		* f1 -> "+"
		* f2 -> PrimaryExpression() - int
		*/
	public R visit(PlusExpression n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("int") || !t2.equals("int"))
			{
				typeError();
			}
		}
		return (R)"int";
	}

	/**   MinusExpression!!!
		* f0 -> PrimaryExpression() - int
		* f1 -> "-"
		* f2 -> PrimaryExpression() - int
		*/
	public R visit(MinusExpression n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("int") || !t2.equals("int"))
			{
				typeError();
			}
		}
		return (R)"int";
	}

	/**   TimesExpression!!!
		* f0 -> PrimaryExpression() - int
		* f1 -> "*"
		* f2 -> PrimaryExpression() - int
		*/
	public R visit(TimesExpression n, A argu) 
	{
			String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("int") || !t2.equals("int"))
			{
				typeError();
			}
		}
		return (R)"int";
	}

	/**   DivExpression!!!
		* f0 -> PrimaryExpression() - int
		* f1 -> "/"
		* f2 -> PrimaryExpression() - int
		*/
	public R visit(DivExpression n, A argu) 
	{
			String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("int") || !t2.equals("int"))
			{
				typeError();
			}
		}
		return (R)"int";
	}

	/**   ArrayLookup!!!
		* f0 -> PrimaryExpression() - int[]
		* f1 -> "["
		* f2 -> PrimaryExpression() - int
		* f3 -> "]"
		*/
	public R visit(ArrayLookup n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String t2 = (String)n.f2.accept(this, null);
		n.f3.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("int[]") || !t2.equals("int"))
			{
				typeError();
			}
		}
		return (R)"int";
	}

	/**   ArrayLength!!!
		* f0 -> PrimaryExpression() - int[]
		* f1 -> "."
		* f2 -> "length"
		*/
	public R visit(ArrayLength n, A argu) 
	{
		String t1 = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		n.f2.accept(this, null);
		if(visit!=0)
		{
			if(!t1.equals("int[]"))
			{
				typeError();
			}
		}
		return (R)"int";
	}

	/**   MessageSend!!! 
		* f0 -> PrimaryExpression()
		* f1 -> "."
		* f2 -> Identifier()
		* f3 -> "("
		* f4 -> ( ExpressionList() )?
		* f5 -> ")"
		*/
	public R visit(MessageSend n, A argu) 
	{
		R _ret=null;
		String ctype = (String)n.f0.accept(this, null);
		n.f1.accept(this, null);
		String mname = (String)n.f2.accept(this, null);
		n.f3.accept(this, null);
		ArrayList<String> argList = new ArrayList<String>();
		n.f4.accept(this, (A)argList);
		n.f5.accept(this, null);

		if(visit!=0)
		{	
			// if(ctype.charAt(0)=='!') 
			// {
			// 	ctype = ctype.substring(1);
			// 	ctype = varTypeMap.get(ctype).peek();
			// }
			
			if(!classTable.containsKey(ctype))
			{
				typeError();
			}
			
			if(!getMeth(mname, ctype))
			{
				typeError();
			}
			
			if(argList.size()!=classTable.get(ctype).methMap.get(mname).arg.argType.size())
			{
				typeError();
			}
			
			for(int i=0;i<argList.size();i++)
			{
				if(!argList.get(i).equals(classTable.get(ctype).methMap.get(mname).arg.argType.get(i)))
				{
					if(!checkParents(argList.get(i), classTable.get(ctype).methMap.get(mname).arg.argType.get(i)))
					{
						typeError();
					}
				}
			}

			_ret = (R)classTable.get(ctype).methMap.get(mname).type;
		}
		return _ret;
	}

	/**   ExpressionList!!!
		* f0 -> Expression()
		* f1 -> ( ExpressionRest() )*
		*/
	public R visit(ExpressionList n, A argu) 
	{
		ArrayList<String> argList = (ArrayList<String>)argu;
		String etype = (String)n.f0.accept(this, argu);
		argList.add(etype);
		n.f1.accept(this, argu);
		return null;
	}

	/**   ExpressionRest!!!
		* f0 -> ","
		* f1 -> Expression()
		*/
	public R visit(ExpressionRest n, A argu) 
	{
		ArrayList<String> argList = (ArrayList<String>)argu;
		n.f0.accept(this, null);
		String etype = (String)n.f1.accept(this, argu);
		argList.add(etype);
		return null;
	}

	/**   PrimaryExpression!!! 
		* f0 -> IntegerLiteral()
		*       | TrueLiteral()
		*       | FalseLiteral()
		*       | Identifier()
		*       | ThisExpression()
		*       | ArrayAllocationExpression()
		*       | AllocationExpression()
		*       | NotExpression()
		*       | BracketExpression()
		*/
	public R visit(PrimaryExpression n, A argu) 
	{
		final Set<String> literal = Set.of("int","boolean","int[]","this");
		R _ret=n.f0.accept(this, (A)"sed");
		String id = (String)_ret;
		if(visit!=0)
		{
			if(!literal.contains(id))
			{
				if(!classTable.containsKey(id))
				{
					typeError();
				}
			}
			else if(id.equals("this")) _ret=(R)curClass;
		}
		return _ret;
	}

	/**   IntegerLiteral!!!
		* f0 -> <INTEGER_LITERAL>
		*/
	public R visit(IntegerLiteral n, A argu) 
	{
		n.f0.accept(this, null);
		return (R)"int";
	}

	/**   TrueLiteral!!!
		* f0 -> "true"
		*/
	public R visit(TrueLiteral n, A argu) 
	{
		n.f0.accept(this, null);
		return (R)"boolean";
	}

	/**   FalseLiteral!!!
		* f0 -> "false"
		*/
	public R visit(FalseLiteral n, A argu)
	{
		n.f0.accept(this, null);
		return (R)"boolean";
	}

	/**   Identifier!!! $ remove debug
		* f0 -> <IDENTIFIER>
		*/
	public R visit(Identifier n, A argu) 
	{
		String huh = (String)argu;
		R _ret=n.f0.accept(this, null);
		String id = (String) _ret;
		if(visit>0)
		{
			if(huh!=null)
			{
				if(!varTypeMap.containsKey(id))
				{
					System.out.println(id);
					typeError();
				}
				_ret = (R)varTypeMap.get(id).peek();
			
			}
		}
		if(visit!=0 && debug>0) 
		{
			System.out.println(id);
		}
		return _ret;
	}

	/**   ThisExpression!!!
		* f0 -> "this"
		*/
	public R visit(ThisExpression n, A argu) 
	{
		return n.f0.accept(this, null);
	}

	/**   ArrayAllocationExpression!!!
		* f0 -> "new"
		* f1 -> "int"
		* f2 -> "["
		* f3 -> Expression() - int
		* f4 -> "]"
		*/
	public R visit(ArrayAllocationExpression n, A argu) 
	{
		n.f0.accept(this, null);
		n.f1.accept(this, null);
		n.f2.accept(this, null);
		String etype = (String)n.f3.accept(this, null);
		n.f4.accept(this, null);

		if(visit!=0)
		{
			if(!etype.equals("int"))
			{
				typeError();
			}
		}
		return (R)"int[]";
	}

	/**   AllocationExpression!!!
		* f0 -> "new"
		* f1 -> Identifier()
		* f2 -> "("
		* f3 -> ")"
		*/
	public R visit(AllocationExpression n, A argu) 
	{
		n.f0.accept(this, null);
		String cname = (String)n.f1.accept(this, null);
		n.f2.accept(this, null);
		n.f3.accept(this, null);

		if(visit!=0)
		{
			if(!classTable.containsKey(cname))
			{
				typeError();
			}
		}
		return (R)cname;
	}

	/**   NotExpression!!!
		* f0 -> "!"
		* f1 -> Expression() - boolean
		*/
	public R visit(NotExpression n, A argu) 
	{
		n.f0.accept(this, null);
		String etype = (String)n.f1.accept(this, null);
		if(visit!=0)
		{
			if(!etype.equals("boolean"))
			{
				typeError();
			}
		}
		return (R)"boolean";
	}

	/**   BracketExpression!!!
		* f0 -> "("
		* f1 -> Expression()
		* f2 -> ")"
		*/
	public R visit(BracketExpression n, A argu) 
	{
		n.f0.accept(this, null);
		String etype = (String)n.f1.accept(this, null);
		n.f2.accept(this, null);
		return (R)etype;
	}


	public R visit(IdentifierList n, A argu) {
		return null;
	}
	public R visit(IdentifierRest n, A argu) {
		return null;
	}

}
